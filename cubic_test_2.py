# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x4jioIXp9LqsC8Uep_-5wKYRC9arkrr0
"""

import matplotlib
import matplotlib.pyplot as plt
import numpy as np
from matplotlib import animation
# %pip install cvxpy
# %pip install scipy
import cvxpy as cp
import scipy as sp
import time
import ps
import os

np.set_printoptions(precision = 3,suppress=True)

def f(x):
    return np.log(x) + 1/x

def lagrange_interpolate(xa,xb,xc,xd):
    M = np.array([[xa**3, xa**2, xa, 1],
                  [xb**3, xb**2, xb, 1],
                  [xc**3, xc**2, xc, 1],
                  [xd**3, xd**2, xd, 1]])
    B = np.array([f(xa),f(xb),f(xc),f(xd)])
    A = np.linalg.solve(M, B)
    return A

def error(xa,xb,xc,xd):
    A = lagrange_interpolate(xa,xb,xc,xd)
    X = np.roots([-3*A[0],-2*A[1],-A[2],1,-1])
    X = X[X>0]
    error = abs(f(X) - (A[0]*X**3 + A[1]*X**2 + A[2]*X + A[3])) 
    return max(error)

def error2(begin,end):
    if begin < end:
        xa = begin
        xd = end
    else:
        xa = end
        xd = begin
    xb = xa + 1/4*(xd-xa)
    xc = xa + 3/4*(xd-xa)
    return error(xa,xb,xc,xd),xb,xc
def search(begin, end, precision):
    pivot = begin
    while abs(begin - end) > 1e-9:
        mid = (begin + end)/2
        a = (f(mid) - f(pivot))/(mid-pivot)
        b = f(mid) - a*mid
        if error2(pivot, mid)[0] <= precision:
            begin = mid
        else:
            end = mid
    return (begin + end)/2

def approximate(precision,eps):
    lines = []
    curr = 2
    while curr - eps > 1e-8:
        next = search(curr,eps,precision)
        xbc = error2(curr, next)
        c = [curr, xbc[2], xbc[1], next]
        #print(c)
        lines.append(c)
        curr = next
    return np.array(lines)

def curve(coeff,eps):
    a,b,c,d = coeff
    xa = eps
    xd = 2
    xb = (xd - xa) * 1/4 + xa
    xc = (xd - xa) * 3/4 + xa
    ya = a*xa**3 + b*xa**2 + c*xa + d
    yb = a*xb**3 + b*xb**2 + c*xb + d
    yc = a*xc**3 + b*xc**2 + c*xc + d
    yd = a*xd**3 + b*xd**2 + c*xd + d
    return xa,xb,xc,xd,ya,yb,yc,yd

precision = 1e-5
eps = 1e-3
file = 'cubic - 2 -' + str(precision) + '-' + str(eps) + '.npy'
if os.path.isfile(os.path.join('preset', file)):
    coeff  = np.load(os.path.join('preset', file))
else:
    curves = approximate(precision,eps)
    coeff = np.zeros((len(curves),4))
    for i in range(len(curves)):
        coeff[i,:] = lagrange_interpolate(curves[i][0],curves[i][1],curves[i][2],curves[i][3])
    np.save(os.path.join('preset', file), coeff)

curves = approximate(precision,eps)
d = 5
n = 5000`
start_total = time.time()
mean = np.zeros(d)
covariance = np.zeros((d,d))

start = time.time()
print("Generating covariance matrix")
count = 0
while True:
    count = count + 1
    for i in range(d):
        for j in range(d):
            if i == j:
                covariance[i,j] = 1.0
            elif i < j:
                covariance[i,j] = np.random.randint(-50,50)/50.0
            else:
                covariance[i,j] = covariance[j,i]
    if ps.is_pos_def(covariance):
        print("Try #",count + 1)
        print(covariance)
        break
    else:
        continue


end = time.time()
print("Generated in {} second\n".format(end - start))
data = np.random.multivariate_normal(mean, covariance, n)


start = time.time()
print("Calculating SN")
sigma = ps.Sn(data)
end = time.time()
print("Calculated in {} second\n".format(end - start))
sqrt_sigma = sp.linalg.sqrtm(sigma)
X_total = cp.Variable((d,d), PSD = True)
Y_total = cp.Variable((d,d))

t = cp.Variable()
I = np.eye(d)
alpha1 = []
alpha2 = []
alpha3 = []
alpha4 = []
X = []
Y = []
Z = []
X_total = cp.Variable((d,d), PSD = True)
Y_total = cp.Variable((d,d))
#X = cp.Variable((d,d), PSD = True)
#Y = cp.Variable((d,d))
#Z = cp.Variable((d,d))
n = min(len(coeff),50)
for i in range(n):
    alpha1.append(cp.Variable((d,d)))
    alpha2.append(cp.Variable((d,d)))
    alpha3.append(cp.Variable((d,d)))
    alpha4.append(cp.Variable((d,d)))
    X.append(cp.Variable((d,d), PSD = True))
    Y.append(cp.Variable((d,d)))
    Z.append(cp.Variable((d,d)))
start = time.time()
print("Generating representation")
constraints = []
count = 0;
for i in range(n):
    Xi = np.flip(curves[i]).tolist()
    Yi = np.flip(f(curves[i])).flatten().tolist()
    #print(Xi)
    #print(Yi)
    #XY = curve(coeff[i],eps)
    #print(coeff[i])
    #print(XY)
    constraints += [cp.bmat ([ 
                                    [3.0 * alpha2[i],   0.0 * I        ],
                                    [0.0 * I        ,  12.0 * alpha4[i]]
                            ]) + 
                cp.bmat     ([      [1.0 * alpha3[i],   2.0 * alpha2[i]],
                                    [2.0 * alpha3[i],   4.0 * alpha3[i]]
                        ]) >> 0*np.eye(2*d)]

    constraints += [cp.bmat ([ 
                                    [3.0 * alpha3[i],   0.0 * I        ],
                                    [0.0 * I        ,  12.0 * alpha1[i]]
                            ]) + \
                cp.bmat     ([      [1.0 * alpha2[i],   2.0 * alpha2[i]],
                                    [2.0 * alpha2[i],   4.0 * alpha3[i]]
                        ]) >> 0*np.eye(2*d)]

    constraints += [alpha1[i] + alpha2[i] + alpha3[i] + alpha4[i] == Z[i]]
    constraints += [alpha1[i] * Xi[0]  + alpha2[i] * Xi[1]  + alpha3[i] * Xi[2]  + alpha4[i] * Xi[3]  == X[i]]
    constraints += [alpha1[i] * Yi[0]  + alpha2[i] * Yi[1]  + alpha3[i] * Yi[2]  + alpha4[i] * Yi[3]  << Y[i]]
    #constraints += [X[i] << 2*I]
    #constraints += [X[i] >> eps*I]
    constraints += [Z[i] >> 0*I]
constraints += [cp.sum(X) == X_total]
constraints += [cp.sum(Y) == Y_total]
constraints += [cp.sum(Z) == I]
constraints += [X_total << 2*I]
constraints += [X_total >> eps*I]
constraints += [cp.trace(Y_total) <= t]
constraints += [(sqrt_sigma @ X_total @ sqrt_sigma)[i,i] == 1 for i in range(d)]
#constraints += [X[i,i] == 1 for i in range(d) ]
end = time.time()
print("Generated in {} second\n".format(end - start))

print("Solving")
prob = cp.Problem(cp.Minimize(t),constraints)
start = time.time()
prob.solve(solver = cp.MOSEK, verbose = True)
end_total = time.time()
# Print result.
print("Solved in {} second\n".format(end_total - start))
print("The optimal value is", prob.value)
print("X = \n",X_total.value)
#print("eig = \n",np.linalg.eig(Z.value)[0])
print("SZS = \n",sqrt_sigma @ X_total.value @ sqrt_sigma)
print(covariance)
print("Y = \n",Y_total.value)
#print("t = \n",t.value)

#print("error = \n", X.value - covariance)

#print("Total time {} second\n".format(end_total - start_total))
